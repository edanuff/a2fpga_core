# A2FPGA DDR3 Framebuffer Refactor — Implementation Workplan

## Project Summary

Refactor the A2FPGA (A2Mega variant) HDMI video output pipeline to use nand2mario's `ddr3_framebuffer` module as the display backend. The key architectural change is moving the video renderers from the HDMI pixel clock domain (`a2bus_if.clk_pixel`) to the Apple II native timing domain (`a2bus_if.clk_logic`, 54 MHz, with Apple II clock enables), outputting pixels via the `fb_*` framebuffer interface instead of direct RGB.

**This creates board-specific renderer variants for the A2Mega only.** The existing `hdl/video/apple_video.sv` and `hdl/video/vgc.sv` remain unchanged for lesser-capable FPGA boards (A2N20v2, etc.). New framebuffer-aware versions live in `boards/a2mega/hdl/video/` and are selected by the A2Mega's `a2mega.gprj` project file.

**Development repo:** https://github.com/edanuff/a2fpga_core (fork, `main` branch)
**ddr3_framebuffer:** https://github.com/nand2mario/ddr3_framebuffer_gowin (`src/ddr3_framebuffer.v`)
**Target hardware:** Sipeed Tang Mega 60K — Gowin **GW5AT-LV60P484A** (via Tang Mega 60K daughterboard module)

---

## Background & Rationale

The current video pipeline in the fork's `top.sv` chains four stages, all driven by HDMI coordinates (`hdmi_x`, `hdmi_y`) generated by the HDMI encoder:

```
apple_video(hdmi_x, hdmi_y) → apple_vga_r/g/b
    ↓
vgc(hdmi_x, hdmi_y, apple_vga_r/g/b) → vgc_vga_r/g/b (SHR muxed when SHRG_MODE)
    ↓
SuperSprite(vgc_vga_r/g/b) → rgb_r/g/b_w (VDP overlaid)
    ↓
DebugOverlay(rgb_r/g/b_w) → debug_r/g/b_w (debug info overlaid)
    ↓
hdmi encoder → TMDS
```

Both `apple_video` and `vgc` run at `clk_pixel` (HDMI timing) and scan VRAM at HDMI beam position, not Apple II beam position. VRAM writes from the Apple II CPU may appear at the wrong scanline because the HDMI and Apple II beams are in different clock domains (59.94 Hz vs 59.92 Hz).

The solution: render at Apple II native timing into a DDR3-backed framebuffer, let the `ddr3_framebuffer` module handle HDMI output independently.

---

## Architecture Decisions

### 1. Keep BlockRAM Shadow VRAM — DDR3 is Framebuffer Only

The existing `apple_memory` module (with `VGC_MEMORY(1)` on A2Mega) provides blockram-backed shadow copies of Apple II video RAM with two separate read ports:

- `video_address_i`/`video_data_o` (32-bit) — regular Apple II video memory
- `vgc_address_i`/`vgc_data_o` (32-bit) — IIgs SHR video memory

**This is not changing.** The blockram shadow VRAM is well-tested across all FPGA boards. The DDR3 is used exclusively as the display framebuffer. This avoids DDR3 bandwidth contention and arbitration complexity.

### 2. Both Renderers Need Framebuffer Variants

- **`apple_video`** — handles text, lores, hires, double-hires, double-lores
- **`vgc`** — handles IIgs Super Hi-Res 320×200 and 640×200 modes

Both currently run on `clk_pixel` driven by `hdmi_x`/`hdmi_y`. Both need re-clocking to Apple II timing with `fb_*` output. In the new architecture, a simple multiplexer in `top.sv` selects which renderer's `fb_*` output feeds the `ddr3_framebuffer` based on `SHRG_MODE`.

### 3. Board-Specific Overrides in `boards/a2mega/hdl/video/`

New framebuffer-compatible renderers go in:
```
boards/a2mega/hdl/video/apple_video_fb.sv
boards/a2mega/hdl/video/vgc_fb.sv
```

The `a2mega.gprj` swaps these in instead of the shared `hdl/video/apple_video.sv` and `hdl/video/vgc.sv`. The originals remain untouched for other boards.

### 4. Clock Domain Architecture — Confirmed from Source

Analysis of `ddr3_framebuffer.v` (nand2mario, March 2025; updated August 2025 for 138K) confirms the write-side interface is fully asynchronous to the HDMI/DDR3 clocks. The module has a dedicated `clk` input (line 43: `// any clock <= 74.25Mhz (or clk_out)`) separate from its internal clock infrastructure.

**Internal clock domains:**

| Clock | Frequency | Source | Purpose |
|-------|-----------|--------|---------|
| `clk` | User-supplied, ≤74.25 MHz | External (our `clk_logic`, 54 MHz) | `fb_*` write interface, config sampling |
| `clk_27` | 27 MHz | External PLL reference (our `clk_pixel_w`) | Seed for `pll_ddr3` |
| `clk_g` | 50 MHz | Board crystal oscillator | DDR3 controller `clk`, mDRP interface |
| `clk_x1` | 74.25 MHz | Generated by DDR3 controller IP (`DDR3_Memory_Interface_Top.clk_out`) | HDMI pixel clock, DDR3 read/write arbitration, upscaling |
| `memory_clk` | ~297 MHz | Generated by `pll_ddr3` from `clk_27` | DDR3 PHY |
| `hclk5` | 371.25 MHz | Generated by `pll_hdmi` from `clk_x1` | TMDS serialization (5× pixel) |
| `hclk` | 74.25 MHz | Generated by `pll_hdmi` from `clk_x1` | TMDS clock lane |

**CDC mechanism — async FIFO (lines 346–350):**
```verilog
asyncfifo #(.BUFFER_ADDR_WIDTH(3), .DATA_WIDTH(COLOR_BITS)) u_asyncfifo (
  .reset(ddr_rst),
  .write_clk(clk), .write(fb_we), .write_data(fb_data), .can_write(),
  .read_clk(clk_x1), .read(fifo_ready), .read_data(fifo_data), .can_read(fifo_ready)
);
```

The async FIFO is 8-deep (`BUFFER_ADDR_WIDTH=3`) with grey-coded pointer CDC (`crossdomain` module = 2-stage synchronizer). Write side runs on `clk` (our 54 MHz), read side runs on `clk_x1` (74.25 MHz). **No additional CDC is needed between our renderers and `ddr3_framebuffer`.**

**`fb_vsync` synchronization (lines 352–362):** Uses toggle-and-sync pattern — `fb_vsync` pulse on `clk` toggles a register, which is double-flopped into `clk_x1` domain. This resets the write position counters.

**Config inputs (`fb_width`, `fb_height`, `disp_width`, `ddr_prefetch_delay`):** Sampled on `clk` domain (line 432) for precalculation of upscaling parameters. These are quasi-static values that change only at mode switches.

**Audio inputs (`sound_left`, `sound_right`):** CDC'd internally with a 2-stage synchronizer into `clk_x1` domain (lines 257–261). Can be driven from any clock domain.

**Write-side pixel accumulation (lines 364–390):** On `clk_x1` domain (after async FIFO), pixels are accumulated 4 at a time, then burst-written to DDR3 as 128-bit words. Read arbitration has priority over writes.

**Implication for A2FPGA:** Renderers on `clk_logic` (54 MHz) with Apple II timing enables write directly to `fb_we`/`fb_data`/`fb_vsync`. Audio signals can be driven from `clk_logic` without explicit CDC. The `ddr3_framebuffer` handles all domain crossing internally.

### 5. Rendering Pipeline — Burst-on-HBlank with Per-Pixel Compositing

Both renderers are triggered on the **long PHI0 cycle** (HBlank marker) and burst-render the just-completed scanline directly to `fb_we`/`fb_data` at `clk_logic` rate. There is no intermediate line buffer — each renderer takes a horizontal pixel coordinate (`burst_x`) and produces one composited pixel per `clk_logic` cycle, straight into the framebuffer.

**Why no line buffer:** The current pipeline already works this way — each stage takes an `x` coordinate and the previous stage's RGB, composites combinationally, and passes it along. The only difference is the clock source (burst counter vs HDMI coordinates). Since each stage reads its own blockram at `burst_x`, the chain is purely combinational/single-cycle-registered per pixel.

**Two rendering paths with different pixel widths:**

The real Apple IIgs VGC uses a different dot clock for SHR modes. Conventional Apple II modes use 14.31818 MHz (7M × 2), producing 560 visible dots per scanline. SHR modes use 16.36363 MHz (8/7 × 14M), producing 640 pixels in the same scanline duration. The SuperSprite TMS9918A VDP was never paired with the IIgs, so it shares the conventional Apple II pixel width.

This means two compositing paths, selected by `SHRG_MODE`:

**Apple II path (560 pixels wide):**
```
burst_x (0-559) → apple_video_fb(x) → SuperSprite(x, apple_rgb) → DebugOverlay(x, rgb) → fb_we/fb_data
fb_width = 560, fb_disp_width = 960
```

**VGC path (640 pixels wide):**
```
burst_x (0-639) → vgc_fb(x) → DebugOverlay(x, vgc_rgb) → fb_we/fb_data
fb_width = 640, fb_disp_width = 1066
```

SuperSprite only participates on the Apple II path (historically accurate). DebugOverlay has no historical precedent and works on either path, handling both widths.

**Burst timing:** On each long PHI0 cycle, `burst_x` counts 0 to `fb_width-1` at `clk_logic` (54 MHz). The entire compositing chain produces one pixel per cycle. Burst duration: 560 pixels ≈ 10.4 µs, 640 pixels ≈ 11.9 µs — both well within the ~25 µs HBlank window.

**Beam racing correctness:** Beam racing in Apple II software operates at scanline granularity (vertical screen splits, post-display-beam object erasure). No known software races the beam within a scanline at dot-clock precision. The beam counter tracks full 65-cycle × 262-line Apple II timing continuously, ensuring VRAM reads from blockram reflect the correct scanline. The burst happens after the visible portion completes, so any CPU writes during the visible portion are captured before rendering.

**`fb_vsync`:** Pulsed at the VBlank transition (line 192 for conventional, line 200 for SHR).

### 6. Shared `scan_timer` Module — Scanline Counting and Burst Trigger

A dedicated module handles all Apple II scanline timing, providing the authoritative beam position and control signals for the burst controller and renderers. It uses `a2bus_if.extended_cycle` (the long PHI0 cycle / HBlank marker) as the fundamental timing reference.

```systemverilog
module scan_timer (
    a2bus_if.slave a2bus_if,
    output [8:0] scanline_o,
    output hsync_o,
    output vsync_o,
    output [9:0] pixel_o
);
    reg [8:0] scanline_counter_r;
    reg vsync_r;
    reg hsync_r;
    reg [9:0] pixel_counter_r;

    always @(posedge a2bus_if.clk_logic or negedge a2bus_if.system_reset_n) begin
        if (!a2bus_if.system_reset_n) begin
            scanline_counter_r <= 9'd0;
            hsync_r <= 1'b0;
            vsync_r <= 1'b0;
            pixel_counter_r <= 10'd0;
        end else begin
            vsync_r <= 1'b0;
            hsync_r <= 1'b0;

            if (pixel_counter_r != 10'b1111111111) begin
                pixel_counter_r <= pixel_counter_r + 1'b1;  
            end

            if (a2bus_if.extended_cycle) begin
                hsync_r <= 1'b1;
                pixel_counter_r <= 10'd0;
                if (scanline_counter_r == 9'd261) begin
                    scanline_counter_r <= 9'd0;
                    vsync_r <= 1'b1;
                end else begin
                    scanline_counter_r <= scanline_counter_r + 1'b1;
                end
            end
        end
    end
    
    assign scanline_o = scanline_counter_r;
    assign hsync_o = hsync_r;
    assign vsync_o = vsync_r;
    assign pixel_o = pixel_counter_r;
    
endmodule
```

**Key signals:**
- `scanline_o` (0-261): Current scanline. Used by renderers to determine VRAM address and by the burst controller to gate visible vs blanked lines.
- `hsync_o`: Single-cycle pulse on `extended_cycle`. **This is the burst trigger** — when asserted, the burst controller begins emitting the just-completed scanline's pixels to `fb_we`.
- `vsync_o`: Single-cycle pulse when scanline wraps 261→0. Drives `fb_vsync` to reset the framebuffer write position.
- `pixel_o` (0-1023): Free-running counter at `clk_logic` (54 MHz) rate, reset each `extended_cycle`. Saturates at 1023. Available for intra-scanline timing if ever needed, but not currently used by the burst renderer.

**Note:** `a2bus_if.extended_cycle` is a fork-specific signal (not in upstream) that detects the long PHI0 cycle at the HBlank boundary. This replaces the manual `apple_hcycle`/`apple_vcycle` beam counter previously described in the workplan.

**Location:** `boards/a2mega/hdl/video/scan_timer.sv` — instantiated once in `top.sv`, outputs shared by all renderers and the burst controller.

---

## Fork-Specific Context (edanuff/a2fpga_core)

The fork has significant changes from upstream that the workplan must account for:

### `a2bus_if.sv` — Renamed Signals

The interface is now parameterless (`interface a2bus_if ()`) with all signals as `logic` members driven by `apple_bus`. **Signal names have changed from upstream:**

| Upstream | Fork |
|----------|------|
| `clk_2m_posedge` | `clk_q3_posedge` |
| `clk_7m` | `clk_7M` |
| `clk_7m_posedge` | `clk_7M_posedge` |
| `clk_7m_negedge` | `clk_7M_negedge` |
| `clk_14m_posedge` | `clk_14M_posedge` |

**New signals in fork:** `phi0_posedge`, `phi0_negedge`, `clk_q3`, `clk_q3_posedge`, `clk_q3_negedge`, `data_in_strobe`, `m2b0`, various `control_*` signals.

The new renderers **must use the fork's signal names**.

### DDR3 — Already in Port List and IP Generated

The fork's `top.sv` already declares DDR3 pins in the port list:
```systemverilog
output [15:0] ddr_addr,    // ROW_WIDTH=16
output [2:0]  ddr_bank,    // BANK_WIDTH=3
output        ddr_cs, ddr_ras, ddr_cas, ddr_we,
output        ddr_ck, ddr_ck_n, ddr_cke, ddr_odt, ddr_reset_n,
output [1:0]  ddr_dm,      // DM_WIDTH=4 (comment says 4 but port is 2)
inout  [15:0] ddr_dq,      // DQ_WIDTH=32 (comment says 32 but port is 16)
inout  [1:0]  ddr_dqs, ddr_dqs_n
```

Currently tied to inactive values with a **commented-out** DDR3 controller instantiation. The Gowin DDR3 IP is already generated at `hdl/gowin/ddr3/DDR3.v` and included in `a2mega.gprj`.

### DebugOverlay

New module at `hdl/debug/debugoverlay.sv`. Sits between SuperSprite and HDMI encoder, overlays debug info (Ensoniq oscillator modes, softswitch states). Takes `screen_x_i`/`screen_y_i` from HDMI. Currently hardcoded on (`show_debug_overlay_r = 1'b1`).

### Ensoniq DOC5503 Sound

New sound chip implementation (`hdl/sound/doc5503.sv`, `hdl/sound/sound_glu.sv`) with 64KB blockram-backed sound RAM via `mem_port_if`. Adds stereo 16-bit signed audio to the mix.

### Audio Pipeline Changes

- Audio is now signed 16-bit throughout
- `cdc_sampling` modules handle CDC from `clk_logic` to `clk_pixel` domain
- New `audio_timing` module (separate from `audio_out`)
- Audio mix includes: Ensoniq (`sg_audio_l/r`) + SuperSprite (`ssp_audio_w`) + Mockingboard (`mb_audio_l/r`) + Apple speaker
- `PIXEL_SPEED_HZ = CLOCK_SPEED_HZ / 2 = 27_000_000` used for audio rate calculations

### ESP32 Octal SPI Interface

New subsystem (`hdl/esp32/`) with `esp32_ospi_connector` for external communication. Provides interfaces for slot configuration, VDP control, video control, and disk volumes.

### Clock PLL

```systemverilog
clk_pll clocks_pll (
    .lock(clk_lock_w),
    .clkout0(clk_pixel_w),    // 27 MHz pixel clock (direct from PLL, no CLKDIV)
    .clkout1(clk_hdmi_w),     // 135 MHz (5× pixel)
    .clkout2(clk_logic_w),    // 54 MHz system clock
    .clkin(clk)
);
```
Note: No `clk_27M_w` output (upstream had one). `clk_pixel_w` is 27 MHz directly from PLL.

### `mem_port_if` — New Memory Interface Pattern

SystemVerilog interface with `controller`/`client` modports:
```systemverilog
interface mem_port_if #(
    parameter PORT_ADDR_WIDTH = 12,
    parameter DATA_WIDTH = 16,
    parameter DQM_WIDTH = 2,
    parameter PORT_OUTPUT_WIDTH = DATA_WIDTH * 2
);
    logic [PORT_ADDR_WIDTH-1:0] addr;
    logic [DATA_WIDTH-1:0] data;
    logic [DQM_WIDTH-1:0] byte_en;
    logic [PORT_OUTPUT_WIDTH-1:0] q;
    logic wr, rd, available, ready;
    modport controller ( ... );
    modport client ( ... );
endinterface
```
Currently used by Ensoniq sound RAM (`mem_port_bram`). Not directly relevant to video but establishes the memory interface pattern.

### `a2mega.gprj` File Structure

The project file uses relative paths from `boards/a2mega/`:
```xml
<!-- Shared modules from ../../hdl/ -->
<File path="../../hdl/video/apple_video.sv" type="file.verilog" enable="1"/>
<File path="../../hdl/video/vgc.sv" type="file.verilog" enable="1"/>
<File path="../../hdl/video/video_control_if.sv" type="file.verilog" enable="1"/>
<File path="../../hdl/video/video.hex" type="file.other" enable="1"/>

<!-- Board-specific modules from hdl/ (relative to boards/a2mega/) -->
<File path="hdl/bus/apple_bus.sv" type="file.verilog" enable="1"/>
<File path="hdl/gowin/ddr3/DDR3.v" type="file.verilog" enable="1"/>
<File path="hdl/gowin/gowin_pll/clk_pll.v" type="file.verilog" enable="1"/>
<File path="hdl/top.sv" type="file.verilog" enable="1"/>
```

To swap renderers, we'll change:
```xml
<!-- Before -->
<File path="../../hdl/video/apple_video.sv" type="file.verilog" enable="1"/>
<File path="../../hdl/video/vgc.sv" type="file.verilog" enable="1"/>
<!-- After -->
<File path="hdl/video/apple_video_fb.sv" type="file.verilog" enable="1"/>
<File path="hdl/video/vgc_fb.sv" type="file.verilog" enable="1"/>
```

---

## Phase 0: Codebase Orientation & Dependency Setup

### Task 0.1 — Verify board file structure and create video directory

Current `boards/a2mega/hdl/` subdirectories: `bus/`, `esp32/`, `gowin/`, `hdmi/`, `sdram/`, `sound/`, `twgs/`

Create: `boards/a2mega/hdl/video/` for the new renderers and `scan_timer.sv`.

### Task 0.2 — Assess DDR3 IP readiness

**Confirmed from source:** `ddr3_framebuffer.v` instantiates its own `DDR3_Memory_Interface_Top` (line 189) — this is the Gowin DDR3 controller IP. It generates the 74.25 MHz `clk_x1` output clock from the DDR3 controller, and takes `memory_clk` (~297 MHz) from `pll_ddr3`.

Key questions to verify:
- **Does the existing `hdl/gowin/ddr3/DDR3.v` match** `DDR3_Memory_Interface_Top`? They're likely the same Gowin IP with possibly different configuration. If ddr3_framebuffer expects a specific configuration (burst length, data width, etc.), we may need to regenerate the IP or use the one bundled with ddr3_framebuffer.
- **The existing `DDR3.v` may conflict** if both are included in the project. Only one DDR3 controller should be instantiated — the one inside ddr3_framebuffer.
- Check the `impl/` directory in ddr3_framebuffer_gowin for pre-generated IP cores for Tang Mega 60K.

### Task 0.3 — Import ddr3_framebuffer sources

**Confirmed repo structure (`src/`):**
```
src/ddr3_framebuffer.v          — Main module + asyncfifo + crossdomain
src/framebuffer2_top.v          — Reference top-level (for study, not import)
src/framebuffer2.sdc            — Timing constraints
src/pll_init.v                  — PLL initialization helper
src/pll_mDRP_intf.v             — Dynamic Reconfiguration Port interface (for 60K PLL stop/start)
src/config.vh                   — Defines (CONSOLE_138K, etc.)
src/console60k/                 — Pre-generated PLLs for Tang Console 60K
src/ddr3_memory_interface/      — DDR3 controller IP
src/hdmi2/                      — HDMI encoder (sameer puri hdmi module variant)
```

Copy into `boards/a2mega/hdl/framebuffer/`:
- `ddr3_framebuffer.v` (includes `asyncfifo` and `crossdomain` modules at bottom of file)
- `pll_init.v`, `pll_mDRP_intf.v`
- `config.vh` — ensure `CONSOLE_138K` is **not** defined (Tang Mega 60K uses the non-138K code path with mDRP interface)
- `src/ddr3_memory_interface/` — DDR3 controller IP. Compare with existing `hdl/gowin/ddr3/DDR3.v`; use whichever matches the expected `DDR3_Memory_Interface_Top` interface.
- `src/hdmi2/` — HDMI encoder. Compare with fork's existing `hdmi.sv`; the ddr3_framebuffer instantiates `hdmi` directly (lines 278-298) with specific parameters.
- `src/console60k/` — PLL cores. These are for Tang Console 60K and **will need regeneration** for Tang Mega 60K / GW5AT-LV60P484A via Gowin IP Generator. Required PLLs: `pll_ddr3` (27 MHz → 297 MHz + unused), `pll_hdmi` (74.25 MHz → 371.25 MHz + 74.25 MHz).

**Resource usage (from comments):** 16 BRAMs, ~3000 LUTs, ~3000 REGs (including DDR3 and HDMI IPs).

### Task 0.4 — Resolve clock infrastructure

Current PLL provides: `clk_pixel_w` (27 MHz), `clk_hdmi_w` (135 MHz), `clk_logic_w` (54 MHz).

**Confirmed from source — ddr3_framebuffer requires three external clocks:**
- **`clk_27`** → `clk_pixel_w` (27 MHz from existing PLL). Used as seed for `pll_ddr3` which generates `memory_clk` (~297 MHz). ✓
- **`clk_g`** → 50 MHz board crystal oscillator. Used for DDR3 controller's `clk` input and the mDRP (Dynamic Reconfiguration Port) interface. The Tang Mega 60K has a 50 MHz crystal — verify pin assignment and route directly to ddr3_framebuffer. This is the same crystal that feeds our existing PLL's `clkin`.
- **`clk`** → `clk_logic_w` (54 MHz). The framebuffer write interface clock. Confirmed: "any clock <= 74.25Mhz". ✓
- **`pll_lock_27`** → `clk_lock_w` from existing PLL. ✓

**PLL accounting — ddr3_framebuffer adds 2 internal PLLs:**
1. `pll_ddr3`: 27 MHz → 297 MHz (DDR3 memory clock). Uses mDRP for stop/start coordination with DDR3 controller.
2. `pll_hdmi`: 74.25 MHz → 371.25 MHz (5× TMDS) + 74.25 MHz (TMDS clock lane).

Since ddr3_framebuffer's HDMI output replaces the existing HDMI encoder, `clk_hdmi_w` (135 MHz) is **no longer needed**. The existing PLL can be simplified to 2 outputs: `clk_pixel_w` (27 MHz) and `clk_logic_w` (54 MHz). Net PLL change: existing HDMI PLL output eliminated, 2 new PLLs added inside ddr3_framebuffer.

**Total PLL count after integration:** Existing board PLL (1) + ddr3_framebuffer's `pll_ddr3` (1) + ddr3_framebuffer's `pll_hdmi` (1) = **3 PLLs**. GW5AT-LV60P484A should support this (verify against device resources).

**Note:** The DDR3 controller IP (`DDR3_Memory_Interface_Top`) generates `clk_x1` (74.25 MHz) as an output — this is the internal pixel clock for HDMI and DDR3 arbitration. It is NOT externally visible to our code; `ddr3_framebuffer` uses it internally.

---

## Phase 1: Integrate ddr3_framebuffer at the Top Level

### Task 1.1 — Instantiate ddr3_framebuffer

Replace the inactive DDR3 pin assignments with actual ddr3_framebuffer instantiation. The DDR3 pin mapping is already in the top module port list — just connect them through.

Parameters:
```verilog
ddr3_framebuffer #(
    .WIDTH(640),           // max horizontal (covers SHR 640×200)
    .HEIGHT(480),          // max vertical
    .COLOR_BITS(18),       // RGB666
    .PREFETCH_DELAY(40)
) u_ddr3_fb (
    // Clock inputs
    .clk_27(clk_pixel_w),          // 27 MHz from existing PLL
    .clk_g(clk_50m),               // 50 MHz board crystal (same pin as PLL clkin)
    .pll_lock_27(clk_lock_w),
    .rst_n(1'b1),                  // DDR3 controller handles its own reset
    .clk_out(),                    // 74.25 MHz output — unused externally
    .ddr_rst(),                    // capture for reset sequencing
    .init_calib_complete(),        // monitor for Phase 1 checkpoint

    // Framebuffer write interface — on clk_logic (54 MHz)
    .clk(clk_logic_w),             // confirmed: "any clock <= 74.25Mhz"
    .fb_width(fb_width_mux),
    .fb_height(fb_height_mux),
    .disp_width(fb_disp_width_mux),
    .fb_vsync(fb_vsync_mux),
    .fb_we(fb_we_mux),
    .fb_data(fb_data_mux),
    .ddr_prefetch_delay(6'd0),     // 0 = use default PREFETCH_DELAY

    // Audio — CDC'd internally via 2-stage sync
    .sound_left(core_audio_l_w),
    .sound_right(core_audio_r_w),

    // DDR3 pins (already in top port list)
    .ddr_addr(ddr_addr), .ddr_bank(ddr_bank), ...
    // HDMI TMDS pins (already in top port list)
    .tmds_clk_p(tmds_clk_p), .tmds_clk_n(tmds_clk_n),
    .tmds_d_p(tmds_d_p), .tmds_d_n(tmds_d_n)
);
```

**Key confirmed details:**
- `clk` input accepts any clock ≤74.25 MHz — our 54 MHz `clk_logic_w` is fine
- Audio inputs are CDC'd internally (2-stage sync to `clk_x1`) — no external CDC needed
- `ddr_prefetch_delay = 0` uses the parameter default (40 cycles); can be made dynamic later if DDR3 bandwidth pressure increases
- The module includes its own `ELVDS_OBUF` for TMDS output (line 301-305) — remove the existing one from top.sv

### Task 1.2 — Test pattern generator

Create a minimal burst controller driving `fb_*` on `clk_logic_w` (54 MHz). Validates the full DDR3 → HDMI path before touching renderers. This also validates the burst timing pattern that will be used by the full pipeline.

The test pattern replaces the compositing chain with a simple color generator:
```systemverilog
// Burst controller drives fb_we at clk_logic rate
// Color bars: fb_data = f(burst_x, burst_y)
// fb_vsync pulsed once per frame at line 192
// fb_width = 560, fb_height = 192, fb_disp_width = 960
```

Protocol (confirmed from source):
1. Assert `fb_vsync` for one `clk` cycle to start a new frame (resets internal write position to 0,0)
2. Assert `fb_we` + `fb_data` for one `clk` cycle per pixel, streaming left-to-right, top-to-bottom
3. Pixels are accumulated 4 at a time internally, then burst-written to DDR3 as 128-bit words
4. `fb_width` must be a multiple of 4
5. Reading (HDMI display) has priority over writing — writes may stall briefly during active display

The burst pattern (emit one scanline per long PHI0 cycle) naturally rate-limits writes to one burst per ~65 µs scanline. The async FIFO is 8-deep and the read side at 74.25 MHz easily keeps up with 54 MHz writes.

### Task 1.3 — Handle HDMI transition

**Confirmed:** ddr3_framebuffer generates its own complete HDMI output chain internally:
- Instantiates `hdmi` encoder (sameer puri variant from `src/hdmi2/`) with VIDEO_ID_CODE=4 (720p60), DVI_OUTPUT=0 (HDMI with audio)
- Instantiates `ELVDS_OBUF` for TMDS differential output (line 301)
- Generates audio at 32 kHz from the 74.25 MHz pixel clock
- Outputs `cx`/`cy` (720p coordinates) used internally for upscaling

The existing pipeline (SuperSprite → DebugOverlay → hdmi encoder → ELVDS_OBUF) must be fully replaced:
- Remove `hdmi` encoder instantiation
- Remove `ELVDS_OBUF` instances (ddr3_framebuffer has its own)
- Remove `DebugOverlay` instantiation (temporarily; restore in Phase 6)
- `clk_hdmi_w` (135 MHz) is no longer needed — ddr3_framebuffer generates its own 371.25 MHz TMDS clock internally via `pll_hdmi`
- Verify TMDS pins are the same physical pins (should be — both drive the same HDMI connector)

### Task 1.4 — Synthesize and verify

**CRITICAL CHECKPOINT**: DDR3 calibration completes, HDMI shows test pattern. Do not proceed until this works.

---

## Phase 2: Create `apple_video_fb.sv`

**Location:** `boards/a2mega/hdl/video/apple_video_fb.sv`

### Task 2.1 — Module interface

The renderer takes a horizontal pixel input (`burst_x`) and produces RGB output, same pattern as the current `apple_video` which takes `screen_x_i`/`screen_y_i`. The key difference: driven by the burst controller during HBlank rather than HDMI coordinates.

```systemverilog
module apple_video_fb (
    a2bus_if.slave a2bus_if,
    a2mem_if.slave a2mem_if,
    video_control_if.display video_control_if,

    // BlockRAM shadow VRAM interface — unchanged
    output reg [15:0] video_address_o,
    output reg video_bank_o,
    output reg video_rd_o,
    input [31:0] video_data_i,

    // Burst rendering interface (replaces screen_x/y inputs and RGB outputs)
    input [9:0]         burst_x,        // horizontal pixel coordinate (0-559)
    input [8:0]         burst_y,        // scanline (0-191)
    input               burst_active,   // high during burst rendering
    output logic [5:0]  video_r_o,      // RGB666 output for compositing chain
    output logic [5:0]  video_g_o,
    output logic [5:0]  video_b_o
);
```

Note: `fb_we`/`fb_data`/`fb_vsync`/`fb_width`/`fb_height`/`fb_disp_width` are NOT outputs of the renderer — they are driven by the burst controller in `top.sv`, which feeds the composited output of the entire chain to the framebuffer.

### Task 2.2 — Scanline timing via `scan_timer`

The renderer does not maintain its own beam counter. The shared `scan_timer` module (instantiated in `top.sv`) provides `scanline_o` and `hsync_o`. The burst controller passes `burst_x` and `burst_y` (derived from `scanline_o`) to the renderer.

The renderer uses `burst_y` to determine which VRAM line to read (via `lineaddr()`) and `burst_x` to determine which pixel within that line to output. Both are provided by the burst controller during the HBlank burst.

### Task 2.3 — Burst rendering pipeline

No line buffer. When `burst_active` is asserted, the renderer takes `burst_x` and produces RGB output combinationally (or single-cycle registered) each `clk_logic` cycle. The existing `apple_video` already works this way — it takes `screen_x_i` and produces RGB in the same cycle via its chunk-based pipeline:

1. `burst_x` determines which 28-pixel chunk to fetch (x / 28)
2. VRAM address generated via `lineaddr()` from `burst_y` + chunk index
3. Blockram returns 32 bits in one cycle
4. Expand function (text/hires/lores/etc.) generates pixel from bit position within chunk
5. Palette lookup → RGB666 output

The 28-pixel chunk structure and shift-register pipeline from `apple_video.sv` are preserved — just driven by `burst_x` instead of `screen_x_i`.

### Task 2.4 — Copy all rendering logic verbatim

From `apple_video.sv`, copy unchanged: `lineaddr()`, all expand functions, video ROM, palettes, artifact table, `pix_history_r`, artifact rotation, nibble capture, `getCurrentNibble()`, line type logic, flash counter, `GR`, `GSP`, `BW`.

### Task 2.5 — Per-scanline mode sampling

Softswitches are latched at the start of each burst (triggered by `hsync` from `scan_timer`):
```systemverilog
always @(posedge a2bus_if.clk_logic) begin
    if (burst_active && burst_x == 0) begin  // first pixel of burst
        text_mode_r <= a2mem_if.TEXT_MODE;
        mixed_mode_r <= a2mem_if.MIXED_MODE;
        hires_mode_r <= a2mem_if.HIRES_MODE;
        // ... same pattern for all softswitches
    end
end
```

This captures the softswitch state at scanline boundaries, which is the correct behavior for beam-racing programs that change modes mid-frame.

### Task 2.6 — Resolution

```systemverilog
// These are constants for the Apple II path — burst controller uses them
localparam APPLE_FB_WIDTH = 11'd560;
localparam APPLE_FB_HEIGHT = 10'd192;
localparam APPLE_FB_DISP_WIDTH = 11'd960;  // 4:3 in 1280-wide 720p frame
```

---

## Phase 3: Create `vgc_fb.sv`

**Location:** `boards/a2mega/hdl/video/vgc_fb.sv`

### Task 3.1 — Module interface

Same pattern as `apple_video_fb` — takes burst coordinates, produces RGB for compositing chain:

```systemverilog
module vgc_fb (
    a2bus_if.slave a2bus_if,
    a2mem_if.slave a2mem_if,
    video_control_if.display video_control_if,

    // BlockRAM VGC memory interface — unchanged
    output vgc_active_o,
    output [12:0] vgc_address_o,
    output vgc_rd_o,
    input [31:0] vgc_data_i,

    // Apple II path RGB input (for muxing when SHR inactive)
    input [5:0]         apple_r_i,
    input [5:0]         apple_g_i,
    input [5:0]         apple_b_i,

    // Burst rendering interface
    input [9:0]         burst_x,        // horizontal pixel coordinate (0-639)
    input [8:0]         burst_y,        // scanline (0-199)
    input               burst_active,   // high during burst rendering
    output logic [5:0]  video_r_o,      // RGB666 output for compositing chain
    output logic [5:0]  video_g_o,
    output logic [5:0]  video_b_o
);
```

When SHR mode is inactive, the VGC passes through the Apple II path's RGB unchanged (same as the current `vgc.sv` behavior). When SHR mode is active, it overrides with its own rendering. The SHRG_MODE mux is internal to the VGC, as it is today.

### Task 3.2 — Pre-burst scanline setup

The VGC has a per-scanline setup sequence that must complete before the burst can begin. This happens during the visible portion of the scanline (while the beam counter is ticking), reading from blockram:

1. **40 display word fetches** (32 bits each = 160 bytes/scanline of pixel data)
2. **1 scanline control byte** (from SHR address $9D00+line, selects 320/640 mode, palette, color fill)
3. **8 palette fetches** (2 colors each = 16 entries loaded per scanline)

These fetches happen at `clk_logic` rate during the visible portion of each scanline (there are ~40×54 = 2160 clk_logic cycles available during the 40 visible CPU cycles). The fetched data is held in registers/local storage. When the long PHI0 triggers the burst, the VGC already has all the data it needs to render each pixel from `burst_x` combinationally.

### Task 3.3 — Burst rendering

During burst, `burst_x` selects a pixel from the pre-fetched scanline data:
- **320 mode:** `burst_x / 2` indexes the pixel (each pixel doubled to fill 640)
- **640 mode:** `burst_x` indexes the pixel directly
- Palette lookup converts 4-bit (320) or 2-bit (640) pixel value to RGB444 → RGB666

### Task 3.4 — Resolution

```systemverilog
// VGC path always renders at 640 wide (320 mode doubles pixels)
localparam VGC_FB_WIDTH = 11'd640;
localparam VGC_FB_HEIGHT = 10'd200;
localparam VGC_FB_DISP_WIDTH = 11'd1066;  // approx 4:3
```

---

## Phase 4: Modify `top.sv` for Framebuffer Pipeline

### Task 4.1 — Burst controller

A small state machine driven by `scan_timer` outputs. On `hsync` (the long PHI0 / extended_cycle pulse), it begins counting `burst_x` from 0 to `fb_width-1`, asserting `burst_active` and `fb_we` for the duration.

```systemverilog
// scan_timer provides authoritative Apple II timing
wire [8:0] scanline;
wire hsync, vsync;
wire [9:0] pixel;

scan_timer scan_timer (
    .a2bus_if(a2bus_if),
    .scanline_o(scanline),
    .hsync_o(hsync),
    .vsync_o(vsync),
    .pixel_o(pixel)
);

// Path selection
wire use_vgc = a2mem_if.SHRG_MODE & !video_control_if.enable;
localparam APPLE_FB_WIDTH = 11'd560;
localparam APPLE_FB_HEIGHT = 10'd192;
localparam APPLE_FB_DISP_WIDTH = 11'd960;
localparam VGC_FB_WIDTH = 11'd640;
localparam VGC_FB_HEIGHT = 10'd200;
localparam VGC_FB_DISP_WIDTH = 11'd1066;

wire [10:0] burst_width = use_vgc ? VGC_FB_WIDTH : APPLE_FB_WIDTH;
wire [9:0]  burst_height = use_vgc ? VGC_FB_HEIGHT : APPLE_FB_HEIGHT;
wire in_visible = (scanline < burst_height);

// Burst state
reg burst_active;
reg [9:0] burst_x;

always @(posedge a2bus_if.clk_logic) begin
    if (hsync && in_visible) begin
        burst_active <= 1;
        burst_x <= 0;
    end else if (burst_active) begin
        if (burst_x == burst_width[9:0] - 1) begin
            burst_active <= 0;
        end else begin
            burst_x <= burst_x + 1;
        end
    end
end

// Framebuffer output — directly from composited chain
assign fb_we = burst_active;
assign fb_data = {final_r, final_g, final_b};  // RGB666 from end of compositing chain
assign fb_vsync = vsync;
assign fb_width = burst_width;
assign fb_height = burst_height;
assign fb_disp_width = use_vgc ? VGC_FB_DISP_WIDTH : APPLE_FB_DISP_WIDTH;
```

### Task 4.2 — Per-pixel compositing chain

Two rendering paths, same structure as today but driven by burst coordinates:

**Apple II path (SHRG_MODE inactive):**
```systemverilog
// Stage 1: Apple II renderer
apple_video_fb apple_video (
    .burst_x(burst_x), .burst_y(burst_y), .burst_active(burst_active),
    .video_address_o(video_address_w), .video_data_i(video_data_w),
    .video_r_o(apple_r), .video_g_o(apple_g), .video_b_o(apple_b), ...
);

// Stage 2: VGC (passes through Apple II RGB when SHR inactive)
vgc_fb vgc (
    .burst_x(burst_x), .burst_y(burst_y), .burst_active(burst_active),
    .apple_r_i(apple_r), .apple_g_i(apple_g), .apple_b_i(apple_b),
    .vgc_address_o(vgc_address_w), .vgc_data_i(vgc_data_w),
    .video_r_o(vgc_r), .video_g_o(vgc_g), .video_b_o(vgc_b), ...
);

// Stage 3: SuperSprite (Apple II path only — overlays VDP on non-SHR output)
supersprite_fb supersprite (
    .burst_x(burst_x), .burst_y(burst_y), .burst_active(burst_active),
    .video_r_i(vgc_r), .video_g_i(vgc_g), .video_b_i(vgc_b),
    .use_vgc(use_vgc),       // when SHR active, pass through without overlay
    .video_r_o(ss_r), .video_g_o(ss_g), .video_b_o(ss_b), ...
);

// Stage 4: DebugOverlay (works on either path)
debugoverlay_fb debugoverlay (
    .burst_x(burst_x), .burst_y(burst_y), .burst_active(burst_active),
    .video_r_i(ss_r), .video_g_i(ss_g), .video_b_i(ss_b),
    .video_r_o(final_r), .video_g_o(final_g), .video_b_o(final_b), ...
);
```

This is the same four-stage chain as today's `apple_video → vgc → SuperSprite → DebugOverlay`, just driven by `burst_x`/`burst_y` instead of `hdmi_x`/`hdmi_y`. Each stage produces one pixel per `clk_logic` cycle.

**Important:** When `use_vgc` is active, the VGC overrides the Apple II RGB. SuperSprite's `use_vgc` input tells it to pass through without overlay (no TMS9918A overlay on SHR content). DebugOverlay works on both paths since it has no historical precedent.

### Task 4.3 — SuperSprite adaptation

The SuperSprite TMS9918A VDP maintains its own VRAM and renders independently. In the current pipeline it overlays based on `screen_x`/`screen_y` coordinates. For the burst pipeline:

- The VDP renderer takes `burst_x`/`burst_y` and reads its own blockram to produce a pixel
- Transparency keying: if VDP pixel is transparent, pass through the input RGB
- When `use_vgc` is asserted, always pass through (no VDP overlay on SHR content)
- The VDP core itself (bus transactions, register access, VRAM writes) continues running on Apple II timing as today — only the video output path changes

This is a straightforward adaptation, not a deferral. The VDP renderer already produces one pixel per clock from coordinates.

### Task 4.4 — DebugOverlay adaptation

Similar to SuperSprite — takes `burst_x`/`burst_y`, composites debug text/status over incoming RGB. Must handle both 560-wide and 640-wide bursts. The debug text rendering (character ROM lookup) works identically to today, just driven by burst coordinates.

### Task 4.5 — Remove old HDMI path

- Remove `hdmi` encoder instantiation (replaced by ddr3_framebuffer's internal `hdmi` from `src/hdmi2/`)
- Remove `ELVDS_OBUF` buffers (ddr3_framebuffer instantiates its own at line 301)
- Remove `hdmi_x`/`hdmi_y` signals (replaced by `burst_x`/`burst_y`)
- **Simplify PLL:** `clk_hdmi_w` (135 MHz) no longer needed — remove from existing PLL. Keep `clk_pixel_w` (27 MHz) and `clk_logic_w` (54 MHz).
- Remove or disable existing `cdc_sampling` modules for audio (ddr3_framebuffer CDC's audio internally)

### Task 4.6 — Audio passthrough

**Confirmed from source (lines 257-261):** `ddr3_framebuffer` CDC's audio internally with a 2-stage synchronizer from the user clock domain to `clk_x1`:
```verilog
always @(posedge clk_x1) begin       // crossing clock domain
    audio_sample_word0[0] <= sound_left;
    audio_sample_word[0] <= audio_sample_word0[0];
    ...
end
```

Therefore: feed `core_audio_l_w`/`core_audio_r_w` directly to `sound_left`/`sound_right`. These are already 16-bit signed in the `clk_logic` domain. **No external CDC or filter chain is needed.** The existing `cdc_sampling` modules and `audio_timing`/`audio_out` chain (which CDC to `clk_pixel`) can be removed or bypassed.

Note: ddr3_framebuffer outputs audio at 32 kHz (AUDIO_OUT_RATE=32000). The fork's audio pipeline may use 48 kHz — verify this is acceptable quality.

### Task 4.7 — Wire ddr3_framebuffer

```systemverilog
ddr3_framebuffer #(
    .WIDTH(640),           // max of both paths
    .HEIGHT(480),          // max vertical
    .COLOR_BITS(18),       // RGB666
    .PREFETCH_DELAY(40)
) u_ddr3_fb (
    .clk_27(clk_pixel_w),
    .clk_g(clk_50m),
    .pll_lock_27(clk_lock_w),
    .rst_n(1'b1),
    .clk(clk_logic_w),             // burst writes on 54 MHz

    .fb_width(fb_width),
    .fb_height(fb_height),
    .disp_width(fb_disp_width),
    .fb_vsync(fb_vsync),
    .fb_we(fb_we),
    .fb_data(fb_data),
    .ddr_prefetch_delay(6'd0),

    .sound_left(core_audio_l_w),
    .sound_right(core_audio_r_w),
    // DDR3 + HDMI TMDS pins ...
);
```

### Task 4.8 — Update `a2mega.gprj`

```xml
<!-- Remove -->
<File path="../../hdl/video/apple_video.sv" type="file.verilog" enable="1"/>
<File path="../../hdl/video/vgc.sv" type="file.verilog" enable="1"/>

<!-- Add -->
<File path="hdl/video/apple_video_fb.sv" type="file.verilog" enable="1"/>
<File path="hdl/video/vgc_fb.sv" type="file.verilog" enable="1"/>
<File path="hdl/video/scan_timer.sv" type="file.verilog" enable="1"/>

<!-- Add ddr3_framebuffer sources -->
<File path="hdl/framebuffer/ddr3_framebuffer.v" type="file.verilog" enable="1"/>
<File path="hdl/framebuffer/pll_init.v" type="file.verilog" enable="1"/>
<File path="hdl/framebuffer/pll_mDRP_intf.v" type="file.verilog" enable="1"/>
<File path="hdl/framebuffer/config.vh" type="file.verilog" enable="1"/>
<!-- ... hdmi2/ sources, ddr3_memory_interface/ sources, PLL cores ... -->

<!-- CRITICAL: Disable or remove existing DDR3 IP to avoid conflict -->
<!-- ddr3_framebuffer instantiates its own DDR3_Memory_Interface_Top -->
<File path="hdl/gowin/ddr3/DDR3.v" type="file.verilog" enable="0"/>  <!-- disabled -->
```

---

## Implementation Status & Bug Fix Log

### Phase 2 Status: `apple_video_fb.sv` — COMPLETE

The `apple_video_fb.sv` renderer is fully implemented and tested. All conventional Apple II video modes render correctly: TEXT40, TEXT80, HGR (with artifact colors), and LORES40.

**Architecture implemented:** The renderer operates on `clk_logic` (54 MHz) with Apple II timing enables. Instead of being driven by HDMI beam position (`screen_x_i`/`screen_y_i`), it self-renders each scanline triggered by `hsync_i` (derived from `a2bus_if.extended_cycle`). Pixels are written directly to the `fb_*` framebuffer interface. A `ddr3_framebuffer` module handles DDR3 storage and HDMI output independently.

**Key implementation details:**
- `WARMUP_PIXELS = 4`: Pipeline runs 4 pixel cycles to prime `pix_history_r` before enabling `fb_we_o`
- `pix_history_r` is reset to zeros at each scanline start (no carry-over between lines)
- Inline combinational color computation (no extra registered pipeline stage for color)
- Step counters (`pix_step4_r`, `pix_step7_r`) advance every pixel cycle including warmup

### Bugs Found & Fixed During Development

| # | Issue | Symptom | Root Cause | Fix | File:Lines |
|---|-------|---------|-----------|-----|------------|
| 1 | **Pixel wrap-around** | ~2 pixels from end of scanline N appeared at start of scanline N+1 | `pix_history_r` carried over across scanlines; apple_video.sv compensates with 32-pixel head start (SCAN_PIX_OFFSET), but FB version had none | Reset `pix_history_r <= '0` at scanline start in ST_IDLE | apple_video_fb.sv:530 |
| 2 | **4-pixel horizontal offset** | All content shifted right by ~4 doubled pixels | HISTORY_PIXEL_OFFSET pipeline delay — first pixels computed from empty/zero history | Added WARMUP_PIXELS=4; run pipeline 4 cycles before enabling fb_we_o | apple_video_fb.sv:63,770 |
| 3 | **Artifact color swap** | HGR colors systematically wrong (magenta↔blue, blue↔green, green↔orange) | Artifact window used post-shift `next_history` instead of pre-shift `pix_history_r`, shifting the 7-bit window by 1 position and changing parity | Changed artifact window to use `pix_history_r[HISTORY_ARTIFACT_OFFSET+6:HISTORY_ARTIFACT_OFFSET]` | apple_video_fb.sv:741 |
| 4 | **TEXT80 garbled** | Character pairs swapped in 80-column mode | Buffer positions for TEXT80 characters were in wrong order vs apple_video.sv (char0↔char1 and char2↔char3 swapped) | Swapped buffer positions to match apple_video.sv: char0→[13:7], char1→[6:0], char2→[27:21], char3→[20:14] | apple_video_fb.sv:623-664 |
| 5 | **LORES nibble lag** | First half of each LORES pixel showed wrong color on color transitions | Used registered `pix_nibble_r` (1 cycle behind) instead of combinational nibble like apple_video.sv's `pix_nibble_w` | Compute `current_nibble` inline via blocking assignment before color mux; register result for next cycle's `prev_nibble` | apple_video_fb.sv:757-761,771,791 |
| 6 | **LORES boundary artifacts** | Thin artifact lines at LORES color bar boundaries | Step counters (`pix_step7_r`, `pix_step4_r`) were gated during warmup, creating phase desync with pixel data in history buffer. Nibble capture at `step7==4` hit wrong position. | Removed warmup gate — step counters now advance every pixel cycle. `pix_step4_r` wraps fully (4 mod 4 = 0); `pix_step7_r` reaches 4 at first output pixel, aligning nibble capture. | apple_video_fb.sv:796-805 |
| 7 | **DDR3 framebuffer race** | Intermittent pixel corruption | Overlapping `if` blocks for `new_frame`/`fifo_draining`/normal-write in ddr3_framebuffer.v | Changed to `if/else if/else` chain | ddr3_framebuffer.v |
| 8 | **Border color mismatch** | Side borders didn't match text background color when SSP active | SSP path used `{nibble, nibble}` → 8-bit → `[7:2]` truncation producing `{nibble[3:0], nibble[3:2]}` (6-bit), while direct/border path used `{nibble, 2'b00}`. Different 6-bit values for same 4-bit input. | Changed `apple_r_o` expansion from `{pix_rgb[11:8], pix_rgb[11:8]}` to `{pix_rgb[11:8], 4'b0}` so SSP truncation `[7:2]` produces `{nibble, 2'b00}`, matching borders | apple_video_fb.sv:815-817 |
| 9 | **1-pixel black notch** | Black pixel at top-left corner and text area transition on each scanline | Non-blocking assignment `apple_r_o <=` in same always block as reading `ssp_r_i` (combinationally depends on `apple_r_o`). First pixel of each scanline reads stale (black) `apple_r_o` because the new value hasn't propagated yet. | Added `ssp_capture_r` flag to defer `fb_data_o`/`fb_we_o` by 1 `clk_logic` cycle. When SSP active, set flag instead of writing immediately; on next cycle, `apple_r_o` has propagated and `ssp_r_i` is valid. | apple_video_fb.sv:385,496-506,814-818 |
| 10 | **VDP 1 scanline too early** | VDP content appeared 1 scanline above correct position | `SL_RESET1` was 260 (1 line too early for the f18a_counters_fb timing). `y_count_en` was being set and `y_count` incremented before the first visible scanline, offsetting all VDP content by 1 line. | Changed `SL_RESET1` from 260 to 261 (= VMAX) so scanline_reset fires at the correct position relative to first visible line. | f18a_counters_fb.vhd:68 |
| 11 | **VDP raster counter too fast** | F18A `y_tick` fired multiple times per scanline | `vdp_cx` incremented every `clk_logic` cycle (54 MHz), reaching HMAX=1023 mid-scanline. Since `y_tick` was a level signal (`hcounter = HMAX`), it stayed high for many cycles, incrementing `y_count` repeatedly. | (a) Added 4× clock divider so `vdp_cx` advances once per 4 `clk_logic` cycles (~857 ticks/line matching `gap_cnt_r`). (b) Reduced HMAX from 1023 to 856. (c) Added edge detectors (`hmax_prev`, `vsize_prev`) for single-cycle `y_tick` and `y_max` pulses. | top.sv:515-536, f18a_vga_cont_fb.vhd:61,94-115 |
| 12 | **VDP screen_y misalignment** | `vdp_cy` drifted from `scanline_w` over time due to independent counter | VDP used its own `vdp_cy` counter that incremented on `hsync_edge_w`. Slight timing differences from `scan_timer`'s `scanline_counter_r` caused accumulated drift. | Fed `scanline_w` directly to `screen_y_i` via `{1'b0, scanline_w}`, eliminating `vdp_cy` entirely. Single source of truth for vertical position. | top.sv:586 |
| 13 | **Sprites/tiles 1 scanline too far down** | VDP sprites appeared 1 line below correct position; some tile backgrounds also offset by 1 line | Missing YPRESCAN equivalent. F18A tile engine uses double-buffered line buffers (even y_next → linebuf1, odd → linebuf2). Original design had non-visible YPRESCAN line with y_next=0 filling first buffer. FB variant went directly to visible line 0 with y_next=1, so row 0 was never prescanned. At 1:1 vertical scale, `y_count` maps directly to `y_half` (no division by 2 to absorb the scanline_reset increment). | (a) Changed `SL_RESET1`/`SL_RESET2` from 261 to 260, giving non-visible prescan on line 261. (b) Modified y_count process: `scanline_reset` only enables `y_count_en` WITHOUT incrementing `y_count`. First prescan at line 261 sees y_count=0/y_next=0, filling linebuf1 with row 0. Line 0 (first visible) reads row 0 from linebuf1 while prescanning row 1 into linebuf2. | f18a_counters_fb.vhd:70-71,188-194 |

### Phase 3 Status: `vgc_fb.sv` — NOT STARTED

IIgs Super Hi-Res rendering (320×200 and 640×200 modes) has not yet been implemented. The existing `vgc.sv` is still used via the project file.

### Phase 4 Status: `top.sv` Integration — COMPLETE (SuperSprite/F18A VDP)

Phase 4 SuperSprite/F18A VDP integration is fully implemented and verified on hardware. The VDP renders correctly in all tested tile and sprite modes with proper vertical and horizontal alignment.

**Architecture implemented:**

The SuperSprite/F18A VDP is integrated into the `apple_video_fb` framebuffer pipeline via a per-pixel compositing loop. Rather than a separate burst-based VDP renderer, the F18A core runs with its own internal timing (driven by an external raster counter synced to `scan_timer`) and its pixel output is composited with the Apple II video in real-time:

1. **`apple_video_fb`** renders an Apple II pixel and exposes it as `apple_r_o`/`apple_g_o`/`apple_b_o`
2. **`SuperSprite`** (containing F18A core) reads the Apple II RGB as its "external video" input and composites the VDP overlay: `ssp_r_o = vdp_pixel_en ? {vdp_r, 4'b0} : video_in_r`
3. **`apple_video_fb`** captures the composited SSP output and writes it to the framebuffer (deferred by 1 cycle via `ssp_capture_r` to handle pipeline latency)

When `ssp_active_i = 1'b1`, every pixel goes through this Apple→SSP→FB loop. When the VDP has a non-transparent pixel, it replaces the Apple II content.

**Board-specific F18A variants created:**

Two new VHDL files provide F18A counter/VGA controller variants adapted for the framebuffer's 560×192 visible area at 1:1 vertical scale:

- **`boards/a2mega/hdl/f18a/f18a_counters_fb.vhd`** — Adapted margins (2× horizontal: XSTART=24, 512 raster pixels for 256 TMS), 1:1 vertical (y_half = y_count directly, no division by 2), prescan timing with YPRESCAN=261 and SL_RESET=260
- **`boards/a2mega/hdl/f18a/f18a_vga_cont_fb.vhd`** — HMAX=856, VMAX=261, VSIZE=192. Single-cycle edge-detected y_tick and y_max pulses. External raster counter input (hcounter/vcounter from top.sv).

**VDP raster counter (top.sv):**

A dedicated counter generates the F18A's `screen_x_i`/`screen_y_i`:
- `vdp_cx`: 10-bit horizontal counter with 4× clock divider (`vdp_div`), advancing once per 4 `clk_logic` cycles to match `apple_video_fb`'s pixel rate. Clamped at VDP_HMAX=856. Reset on `hsync_w`.
- `screen_y_i`: Fed directly from `scan_timer`'s `scanline_w` (0-261) — single source of truth for vertical position.

**Key technical insights documented below in "F18A Integration Technical Notes" section.**

---

## Phase 5: Testing & Validation

### Task 5.1 — Basic video modes
- [x] 40-column text, cursor flash
- [x] Lores graphics (`GR: FOR I=0 TO 39: COLOR=I: VLIN 0,39 AT I: NEXT`)
- [x] HGR — artifact colors correct
- [x] Mixed mode
- [x] 80-column text (PR#3)
- [ ] DHGR, Double Lores
- [ ] IIgs SHR 320-mode — per-scanline palette, color fill
- [ ] IIgs SHR 640-mode — dithered colors

### Task 5.2 — Beam racing
- [ ] Rasterbar demos at correct scanlines
- [ ] Mid-frame mode switching
- [ ] Split-screen effects

### Task 5.3 — Renderer switching
- [ ] Text → SHR and SHR → text transitions (fb_width changes 560 ↔ 640)
- [ ] Rapid SHRG_MODE toggling
- [ ] Verify ddr3_framebuffer handles dynamic width/height changes cleanly

### Task 5.4 — Compositing chain
- [x] SuperSprite VDP overlay on Apple II modes (transparency keying)
- [ ] SuperSprite correctly disabled during SHR mode
- [x] DebugOverlay visible on Apple II modes (560-wide)
- [ ] DebugOverlay visible on SHR modes (640-wide)
- [x] Full chain: apple_video → SuperSprite overlay → DebugOverlay → framebuffer
- [x] VDP tile modes — correct vertical alignment (row 0 renders on line 0)
- [x] VDP sprite positioning — correct Y position (sprites at expected scanlines)
- [x] VDP border colors match Apple II background color through SSP compositing
- [x] No pixel artifacts at scanline boundaries (notch fix verified)

### Task 5.5 — Stability
- [x] Extended operation (hours)
- [x] DDR3 calibration stable
- [x] 4:3 aspect ratio, border colors, upscaling quality
- [x] Audio (speaker, Mockingboard, SuperSprite, Ensoniq)
- [x] Burst timing: verify all pixels emitted within HBlank window
- [x] Timing closure: clk_logic 55.018 MHz actual vs 54.000 MHz constraint (0 violations)

---

## Phase 6: Optimization & Future Work

### Task 6.1 — DDR3 shared access for extended RAM
Framebuffer uses ~5-10% of DDR3 bandwidth. Evaluate sharing for IIgs extended RAM, ROM, disk buffering.

### Task 6.2 — Scanline effects
Reimplement scanline darkening in the renderer or framebuffer read path.

### Task 6.3 — Dynamic resolution switching optimization
Verify clean transitions when `fb_width`/`fb_height` change between 560×192 and 640×200 mid-session (SHRG_MODE toggle). The ddr3_framebuffer supports dynamic size changes but the upscaling logic needs a frame to adapt.

### Task 6.4 — Audio sample rate
Investigate modifying ddr3_framebuffer's `AUDIO_OUT_RATE` from 32 kHz to 48 kHz for improved audio quality, particularly for Ensoniq wavetable output.

---

## Key Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation | Status |
|------|-----------|--------|------------|--------|
| ddr3_framebuffer incompatible with GW5AT-LV60P484A | **Low** | High | nand2mario designed it for Tang Mega 60K; PLLs in `src/console60k/` may need regeneration for the exact device variant | ✅ Resolved — working on hardware |
| PLL count exceeded (3 total needed) | Low | High | ddr3_framebuffer's 2 PLLs replace the existing HDMI PLL output; net +1 PLL. Verify GW5AT PLL count. | ✅ Resolved — 3 PLLs fit |
| ddr3_framebuffer DDR3 IP conflicts with existing `DDR3.v` | **Confirmed risk** | Medium | ddr3_framebuffer instantiates its own `DDR3_Memory_Interface_Top`. Must use ddr3_framebuffer's version or verify they're identical. Remove or disable existing `DDR3.v` from project. | ✅ Resolved — using ddr3_framebuffer's IP |
| Async FIFO overflow (fb_we too fast) | Low | Medium | FIFO is 8-deep; burst writes at 54 MHz during HBlank (~640 pixels in 11.9 µs) are well within the 74.25 MHz read-side capacity. | ✅ No issues observed |
| `clk_g` 50 MHz routing | Low | Low | Same crystal pin as existing PLL `clkin`; verify it can drive both the existing PLL and ddr3_framebuffer's `clk_g` (may need BUFG fanout). | ✅ Resolved — works with direct routing |
| VGC per-scanline palette timing broken | Medium | Medium | Pre-burst fetch sequence must complete before long PHI0 triggers burst | Open — VGC not started |
| Burst pipeline latency exceeds HBlank | Low | Medium | 640 pixels at 54 MHz = 11.9 µs; HBlank ≈ 25 µs. Even with 4-stage compositing chain, single-cycle-per-pixel is achievable. | ✅ Verified — 560 pixels renders cleanly within window |
| SuperSprite VDP burst rendering | Medium | Medium | VDP renderer must produce one pixel per `clk_logic` cycle from `burst_x`; current implementation may need pipelining | ✅ Resolved — F18A runs with its own internal timing, composited per-pixel via SSP loop rather than burst-based rendering |
| DebugOverlay dual-width handling | Low | Low | Must handle both 560-wide and 640-wide bursts; character positioning needs to account for variable width | ✅ Resolved — DebugOverlay adapted for 720p with 560-wide content |
| Artifact color context broken | Medium | Medium | Preserve pix_history shift register exactly | ✅ Resolved — artifact colors correct after warmup pipeline fix |
| Audio quality (32 kHz output) | Low | Low | ddr3_framebuffer outputs at 32 kHz; may want to modify to 48 kHz for better quality | ✅ Resolved — audio_rate parameter matched, working |
| F18A prescan/double-buffer alignment | **Discovered** | High | F18A tile engine uses double-buffered line buffers. At 1:1 vertical scale, the original 2× division-by-2 no longer absorbs the initial y_count increment. Must provide a non-visible prescan line and separate enable from increment on scanline_reset. | ✅ Resolved — SL_RESET=260, enable-only on scanline_reset |
| SSP combinational pipeline delay | **Discovered** | Medium | Non-blocking assignment of `apple_r_o` means `ssp_r_i` (which depends combinationally on `apple_r_o`) reads stale value on first pixel of each scanline. | ✅ Resolved — ssp_capture_r defers write by 1 clk cycle |

---

## F18A Integration Technical Notes

### VHDL Bit Indexing Convention

The F18A VHDL code uses descending-to-ascending bit ordering (`unsigned(0 to N)`) where **bit 0 is the MSB**. This is the opposite of Verilog convention:

| VHDL Declaration | Bit 0 | Bit N | Equivalent Verilog |
|---|---|---|---|
| `unsigned(0 to 8)` | MSB (value 256) | LSB (value 1) | `[8:0]` with bit 8 = MSB |
| `y_count(0 to 7)` | Bits 0-7 = upper 8 bits | — | Divide by 2 (right-shift) |
| `y_count(1 to 8)` | Bits 1-8 = lower 8 bits | — | Direct value (no division) |

**Critical for fb variant:** The original `y_half <= y_count(0 to 7)` divides by 2 for 2× VGA vertical scaling. The fb variant uses `y_half <= y_count(1 to 8)` for 1:1 scale (no division). Getting this wrong causes either half the expected lines or doubled/skipped lines.

### F18A Double-Buffered Tile Line Buffers

`f18a_tile_linebuf.vhd` contains **two independent 512×8 line buffers** (linebuf1, linebuf2) that alternate based on the LSB of `y_next_r`:

```vhdl
-- Write to one buffer based on y_next parity
we1 <= (not y_next_r(8)) and we_sel;   -- even y_next → write linebuf1
we2 <= y_next_r(8) and we_sel;          -- odd y_next  → write linebuf2

-- Read from the OTHER buffer (double-buffering)
tile_color <= dout1 when y_next_r(8) = '1' else dout2;
```

Note: `y_next_r(8)` is the **LSB** (bit 8 in VHDL `0 to 8` ordering = value 1).

**Double-buffer flow:**
- When y_next is even (e.g., 0): prescan writes to linebuf1, pixel engine reads from linebuf2
- When y_next is odd (e.g., 1): prescan writes to linebuf2, pixel engine reads from linebuf1

**Consequence:** You need TWO prescan cycles before the first visible line reads correctly:
1. Non-visible prescan line: fills buffer A with row 0
2. First visible line: prescan fills buffer B with row 1, pixel engine reads buffer A (row 0) ✓

### F18A Prescan Timing — Original vs FB Variant

**Original (2× VGA vertical scale):**
```
SL_RESET1=46 → scanline_reset at raster_y=46
YPRESCAN=47  → first prescan line (non-visible), y_count=1, y_half=0 (÷2), y_next=0
YSTART=48    → first visible line, y_count=2, y_half=1, y_next=1
               reads linebuf1 (filled with row 0 at YPRESCAN) ✓
```

The 2× division absorbs the increment: `y_count=1 → y_half = y_count(0 to 7) = 0`.

**FB variant (1:1 vertical scale) — FIXED:**
```
SL_RESET1=260 → scanline_reset at raster_y=260, enables y_count_en (NO increment)
Line 261       → prescan (non-visible), y_count=0, y_half=0, y_next=0
                 fills linebuf1 with row 0
Line 261 end   → y_tick increments y_count to 1
Line 0         → first visible, y_count=1, y_half=1, y_next=1
                 prescan fills linebuf2 with row 1
                 pixel engine reads linebuf1 (row 0) ✓
```

At 1:1 scale, `y_half = y_count(1 to 8) = y_count` directly. The scanline_reset must NOT increment y_count — only enable y_count_en. Otherwise y_count starts at 1 and row 0 is never prescanned.

### F18A Sprite Y Position

```vhdl
y_sprt_pos <= y_half - 1 when sprt_yreal = '0' else y_half;
```

This means sprites are "1 line behind the raster" by default (TI 9918A compatibility). With the prescan fix:
- Line 0 (first visible): y_half=1, y_sprt_pos = 1-1 = 0 ✓
- Line 1: y_half=2, y_sprt_pos = 2-1 = 1 ✓

On the non-visible prescan line (261): y_half=0, y_sprt_pos = 0-1 = 255 (unsigned wrap). This is fine — line 261 is non-visible, so the wrapped sprite position has no visible effect.

### SuperSprite Compositing Pipeline

The SuperSprite output is purely combinational — no internal registers between input and output:

```verilog
assign ssp_r_o = vdp_pixel_en ? {vdp_r, 4'b0} : video_in_r;
```

Where `video_in_r` is the Apple II RGB from `apple_video_fb`'s `apple_r_o`. Since `apple_r_o` is assigned via non-blocking `<=`, on the same clock edge that sets `apple_r_o`, `ssp_r_o` still reflects the OLD value. This is why `ssp_capture_r` defers the framebuffer write by 1 cycle — by the next cycle, `apple_r_o` has updated and the combinational SSP path outputs the correct value.

### VDP Raster Counter Design

The F18A's `screen_x_i`/`screen_y_i` must match the framebuffer's scanline timing exactly:

- **Horizontal:** `vdp_cx` uses a 4× clock divider (`vdp_div`) to advance once per 4 `clk_logic` cycles, matching `apple_video_fb`'s `gap_cnt_r` pixel rate. This gives ~857 ticks per scanline (54 MHz / 4 × ~63.5 µs). Clamped at VDP_HMAX=856.
- **Vertical:** Uses `scanline_w` directly from `scan_timer` — single source of truth. No separate VDP vertical counter.
- **Edge detection:** `f18a_vga_cont_fb.vhd` uses `hmax_prev`/`vsize_prev` registers to produce single-cycle pulses for `y_tick` and `y_max`. Without edge detection, the level signals would fire for many cycles while `hcounter = HMAX` (since the counter clamps), causing `y_count` to increment many times per scanline.

---

## Notes for Claude Code

- **Use fork signal names**: `clk_7M_posedge` not `clk_7m_posedge`, `clk_14M_posedge` not `clk_14m_posedge`, `clk_q3_posedge` not `clk_2m_posedge`.
- **New files go in `boards/a2mega/hdl/video/`**. Do not modify files in `hdl/video/`.
- **BlockRAM shadow VRAM is unchanged.** `apple_memory` and its interfaces remain exactly as-is.
- **DDR3 pins are already in the top module port list** and DDR3 IP is already generated. Don't add new port declarations — just replace the inactive tie-offs with actual connections.
- **`clk_logic` is 54 MHz.** Apple II timing via enables: `phi1_posedge`, `clk_7M_posedge`, `clk_14M_posedge`.
- **`clk_pixel_w` is 27 MHz** (direct from PLL, not via CLKDIV). Feeds ddr3_framebuffer's `clk_27`.
- **`clk_g` needs 50 MHz board crystal** — same physical pin as PLL `clkin`. May need signal fanout.
- **Rendering is burst-on-HBlank.** Long PHI0 cycle triggers burst. Renderers take `burst_x`/`burst_y`, produce one composited pixel per `clk_logic` cycle, directly to `fb_we`/`fb_data`. No intermediate line buffer.
- **Two rendering paths with different widths.** Apple II path: 560 wide. VGC/SHR path: 640 wide. `SHRG_MODE` selects which path is active. SuperSprite only on Apple II path.
- **Renderers output RGB, not fb_* signals.** The burst controller in `top.sv` drives `fb_we`/`fb_data`/`fb_vsync`/`fb_width` from the composited output of the rendering chain.
- **`fb_width` must be a multiple of 4** (pixels accumulated in groups of 4 for DDR3 burst writes). 560 and 640 are both multiples of 4. ✓
- **Audio can be driven from `clk_logic` domain** — ddr3_framebuffer CDC's internally with 2-stage sync.
- **ddr3_framebuffer includes its own `ELVDS_OBUF`** — remove the existing one from top.sv.
- **ddr3_framebuffer includes its own `DDR3_Memory_Interface_Top`** — verify compatibility with or replace existing `hdl/gowin/ddr3/DDR3.v`.
- **Preserve all rendering math verbatim** from `apple_video.sv` and `vgc.sv`.
- **The `video.hex` character ROM** is shared — ensure path resolves from new location.
- **Commit at each phase boundary** for clean rollback.
- **Phase 1 checkpoint is critical** — DDR3 calibration (`init_calib_complete`) + HDMI test pattern must work first.
- **Device is GW5AT-LV60P484A** (Tang Mega 60K module).
- **SHR dot clock is 16.36 MHz (8/7 × 14M)**, but the burst renderer doesn't need to match this — it reads pre-fetched scanline data and produces 640 pixels at `clk_logic` rate during HBlank.
- **`scan_timer` is the single source of truth** for scanline position and burst timing. Uses `a2bus_if.extended_cycle` (fork-specific signal for long PHI0 / HBlank). Instantiated once in `top.sv`, outputs shared by burst controller and all renderers.
- **`a2bus_if.extended_cycle`** is the fork's signal for detecting the long PHI0 cycle at the scanline boundary. This is the burst trigger — replaces manual cycle counting.
- **F18A board variants** go in `boards/a2mega/hdl/f18a/`. `f18a_counters_fb.vhd` and `f18a_vga_cont_fb.vhd` replace the shared `hdl/f18a/` versions via the `.gprj` file. Do not modify `hdl/f18a/f18a_counters.vhd` or `hdl/f18a/f18a_vga_cont_640_60.vhd`.
- **F18A VHDL uses `unsigned(0 to N)` where bit 0 is MSB.** `y_count(0 to 7)` = divide by 2 (upper 8 bits). `y_count(1 to 8)` = direct value (lower 8 bits). The fb variant uses `(1 to 8)` for 1:1 vertical scale.
- **F18A tile engine has double-buffered line buffers.** Even/odd y_next selects which buffer to write/read. A non-visible prescan line is required before the first visible line. The fb variant achieves this with SL_RESET=260 (enabling y_count_en at end of line 260) and prescan on line 261 (y_count=0).
- **SuperSprite compositing is per-pixel via `apple_video_fb`**, not burst-based. `apple_r_o`/`apple_g_o`/`apple_b_o` feed the SSP combinational path, which feeds back `ssp_r_i`/`ssp_g_i`/`ssp_b_i`. The fb_data_o write is deferred 1 cycle when SSP is active (via `ssp_capture_r`) to let `apple_r_o` propagate.
- **VDP raster counter** in `top.sv` uses a 4× clock divider (VDP_HMAX=856, ~857 ticks/line). `screen_y_i` comes directly from `scanline_w`. Edge-detected `y_tick`/`y_max` pulses prevent multi-increment bugs.
- **RGB bit expansion for SSP path** must use `{nibble, 4'b0}` (not `{nibble, nibble}`) so that truncation to `[7:2]` produces `{nibble, 2'b00}`, matching the direct border/Apple II RGB expansion path.
- **When modifying F18A prescan timing**, remember that `scanline_reset` enable-only (no increment) is critical at 1:1 vertical scale. The original 2× design absorbs the first increment via division by 2.
